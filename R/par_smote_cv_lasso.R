#' Parameter tuning for LASSO using parallel computing
#'
#' This function employs parallel computing to perform k-fold cross-validation for LASSO regression on datasets with an imbalanced binary outcome, enabling the tuning of the regularization parameter, \eqn{\lambda}.
#'
#' @param X feature matrix or \code{cv_smote_dataList} generated by function \code{stratified_cv_smote}
#' @param y binary outcome, where 1 = positive event & minority class and 0 = negative event & majority class; ignored if \code{x} is \code{cv_smote_dataList}
#' @param nlambda number of \code{lambda} values, default value is 100; ignored if \code{lambda} is supplied by user
#' @param lambda \code{lambda} sequence, typically computed by program based on \code{nlambda} and input data
#' @param \dots other arguments that can be passed to \code{stratified_cv_smote} or \code{glmnet}
#'
#' @examples
#' # example code
#'
#' @export

par_smote_cv_lasso <- function(
    X,
    y = NULL,
    nlambda = 100,
    lambda = NULL,
    ...
) {
  # check whether input X is a featured list or a matrix
  if(!(methods::is(X, "cv_smote_dataList"))) {
    if(!is.matrix(X)) {
      if(is.data.frame(X)) X <- as.matrix(X)
      else stop("X should be either a cv_smote_dataList or a matrix.")
    } else {
      if(is.null(y))
        stop("Input y is required given input X is a matrix!")
      else {
        X <- stratified_cv_smote(X, y, ...)
      }
    }
  }

  X1 <- do.call(rbind, X$test) |> as.matrix()
  if(is.null(lambda)) lambda <- lambda_gen(X1[, -ncol(X1)], X1[, ncol(X1)], K = nlambda)$Lambdas

  mse <- function(i) {
    testdata <- X$test[[i]]
    traindata <- X$train[[i]]
    nX <- ncol(testdata) - 1
    fit <- glmnet::glmnet(traindata[, 1:nX], traindata[, nX+1], family = "binomial", lambda = lambda, ...)
    pred <- stats::predict(fit, newx = as.matrix(testdata[, 1:nX]), s = lambda)
    apply(pred, 2, \(x) mean((x-testdata[, nX+1]) ^ 2))
  }

  cores <- min(length(X$test), parallel::detectCores() - 1)
  cl <- parallel::makeCluster(cores)
  on.exit(parallel::stopCluster(cl))
  parallel::clusterExport(cl, c("X", "mse"), envir = environment())
  res <- parallel::parSapply(cl, seq(length(X$test)), mse)

  res <- cbind(res, lambda)
  class(res) <- c("smote_cv_mseMatrix", "matrix")
  return(res)
}
