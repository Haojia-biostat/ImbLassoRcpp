# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'Generate the lambda sequence for LASSO
#'
#'This function produces a decreasing lambda sequence with a length of \code{K} for LASSO,
#'based on the feature matrix \code{X} and binary outcome \code{y}.
#'
#'@name lambda_gen
#'
#'@param X feature matrix
#'@param y binary outcome, where 1 = positive event and 0 = negative event
#'@param K number of lambdas, default value is 100
#'
#'@return A list including:
#'\item{Entry value}{\eqn{\lambda_{max}}, the smallest value for which all coefficients are zero}
#'\item{Minimum ratio}{\eqn{\lambda_{min}} as a fraction of \eqn{\lambda_{max}}}
#'\item{Lambdas}{\code{K} values of \eqn{\lambda} decreasing from \eqn{\lambda_{max}} to \eqn{\lambda_{min}} on the log scale}
#'
#'@references
#'Friedman, J., Hastie, T. and Tibshirani, R. (2008)
#'\emph{Regularization Paths for Generalized Linear Models via Coordinate Descent (2010),
#'Journal of Statistical Software, Vol. 33(1), 1-22},
#'\doi{10.18637/jss.v033.i01.}
#'
#'@examples
#'X <- matrix(rnorm(1000), ncol = 10)
#'y <- rbinom(100, 1, 0.1)
#'lambda_gen(X, y, K = 15)
#'
#'@export
NULL

lambda_gen <- function(X, y, K = 100L) {
    .Call(`_ImbLassoRcpp_lambda_gen`, X, y, K)
}

#'Apply SMOTE algorithm to the X of minority class
#'
#'This function generates new observations for the X of minority class in the binary outcome
#'using the SMOTE (i.e., synthetic minority over-sampling technique) algorithm.
#'
#'For each of the observations in minority class, \code{k} nearest neighbors will be defined
#'by Euclidean distance, and the following steps will be repeated for \code{N} times:
#'
#'1. Randomly draw one of the k nearest neighbors;
#'
#'2. Take difference between the observation and the neighbor;
#'
#'3. Multiply the difference by a random number in \code{(0,1]};
#'
#'4. Add this difference to the observation to generate a new synthetic example in feature space;
#'
#'5. If \code{k < N}, put the neighbor back to the sampling pool.
#'
#'@name smote_minor_x
#'
#'@param X feature matrix
#'@param k number of nearest neighbors to be identified, default value is 5
#'@param N number of new synthetic examples to be generated for each observation, default value is 9
#'
#'@return A list including:
#'\item{kNN}{matrix of the row index of nearest neighbors for each observation in \code{X}
#'with \code{nrow(X)} rows and \code{k} columns}
#'\item{Euclidean}{matrix of Euclidean distance with \code{nrow(X)} rows and columns}
#'\item{Synthetic}{matrix of new synthetic examples with \code{nrow(X)*N} rows and \code{ncol(X)} columns}
#'
#'@references
#'\url{https://medium.com/@corymaklin/synthetic-minority-over-sampling-technique-smote-7d419696b88c}
#'
#'@examples
#'X <- matrix(rnorm(50), ncol = 10)
#'smote_minor_x(X, k = 3, N = 2)
#'
#'@export
NULL

smote_minor_x <- function(X, k = 5L, N = 9L) {
    .Call(`_ImbLassoRcpp_smote_minor_x`, X, k, N)
}

#'Stratified cross-validation sampling
#'
#'This function splits the observations to k-fold cross validation.
#'
#'@name stratified_cv
#'
#'@param y binary outcome, where 1 = positive event and 0 = negative event
#'@param k number of folds, default value is 10
#'@param stratified logical flag for whether to ensure that each fold contains a proportional representation
#'of each class or stratum, default value is TRUE
#'
#'@return A vector with the same length as \code{y} containing fold id from 1 to \code{k}
#'
#'@examples
#'y <- rbinom(2023, 1, 0.1)
#'tapply(y, stratified_cv(y), sum)
#'tapply(y, stratified_cv(y, stratified = FALSE), sum)
#'
#'@export
NULL

stratified_cv <- function(y, k = 10L, stratified = TRUE) {
    .Call(`_ImbLassoRcpp_stratified_cv`, y, k, stratified)
}

