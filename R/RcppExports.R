# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

coord_desc <- function(X, y, lambda, thresh = 1e-7, maxit = 1e5L) {
    .Call('_ImbLassoRcpp_coord_desc', PACKAGE = 'ImbLassoRcpp', X, y, lambda, thresh, maxit)
}

logit_i <- function(X, b0, b) {
    .Call('_ImbLassoRcpp_logit_i', PACKAGE = 'ImbLassoRcpp', X, b0, b)
}

#'run the coordinate descent algorithm on the penalized weighted-least-squares
#'
#'Update the quadratic approx
#'
#'@name single_coord_des
#'
#'@param X input matrix, of dimension nobs x nvars; each row is an observation vector.
#'@param y binary response variable, positive outcome = 1 and negative outcome = 0.
#'@param lambda A user supplied lambda
#'@param thresh Convergence threshold for coordinate descent. Each inner coordinate-descent loop continues until the maximum change in the objective after any coefficient update is less than thresh times the null deviance. Defaults value is 1E-7.
#'@param maxit Maximum number of passes over the data for all lambda values; default is 10^5.
#'
betamat <- function(X, y, lambda, thresh = 1e-7, maxit = 1e5L) {
    .Call('_ImbLassoRcpp_betamat', PACKAGE = 'ImbLassoRcpp', X, y, lambda, thresh, maxit)
}

prob_i <- function(logit) {
    .Call('_ImbLassoRcpp_prob_i', PACKAGE = 'ImbLassoRcpp', logit)
}

smoteCpp <- function(X, y, k, m) {
    .Call('_ImbLassoRcpp_smoteCpp', PACKAGE = 'ImbLassoRcpp', X, y, k, m)
}

soft_thresh <- function(z, gamma) {
    .Call('_ImbLassoRcpp_soft_thresh', PACKAGE = 'ImbLassoRcpp', z, gamma)
}

stratifiedCpp <- function(X, y, size) {
    .Call('_ImbLassoRcpp_stratifiedCpp', PACKAGE = 'ImbLassoRcpp', X, y, size)
}

weight_i <- function(prob) {
    .Call('_ImbLassoRcpp_weight_i', PACKAGE = 'ImbLassoRcpp', prob)
}

